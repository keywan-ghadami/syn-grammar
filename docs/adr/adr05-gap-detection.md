# ADR-05: Resolve Parsing Ambiguity with Gap Detection in the Grammar Parser

**Status:** Proposed

**Context:**

The current parser for the `grammar!` macro has an ambiguity when it encounters a pattern like `ident (...)`. This can be interpreted in two ways:

1.  **Rule call with arguments:** `ident(...)` (e.g., `MyRule(a, b)`)
2.  **A sequence of two patterns:** A call to the rule `ident` followed by a grouped expression `(...)` (e.g., `MyRule (a | b)`).

This ambiguity is particularly problematic because `syn` (and Rust macro parsing in general) treats whitespace as insignificant between tokens. `ident (...)` and `ident(...)` result in the same token stream. To distinguish between them, we must inspect the `Span` of the tokens to see if they are adjacent in the source code.

**Decision:**

We will resolve this ambiguity by making the grammar parser whitespace-sensitive in this specific context. The logic will be implemented in `syn-grammar-model/src/parser.rs`.

- If there is **no whitespace** between an identifier (`ident`) (or the closing angle bracket `>` of generics) and a subsequent opening parenthesis (`(`), the parser will model this as a `ModelPattern::RuleCall` with arguments.
- If there is **whitespace** (a "gap"), the parser will model this as a `ModelPattern::RuleCall` with *no* arguments, followed by a separate `ModelPattern::Group` (which will be parsed in the next iteration).

**Detailed Implementation Plan:**

The changes will be focused on `syn-grammar-model/src/parser.rs`, specifically within the function that parses a `Pattern` (likely `parse_atom` or similar).

1.  **Span Contiguity Check:**
    We need a utility to determine if two spans are immediately adjacent.

    ```rust
    use proc_macro2::{LineColumn, Span};

    fn spans_are_contiguous(first: Span, second: Span) -> bool {
        let first_end: LineColumn = first.end();
        let second_start: LineColumn = second.start();

        // Must be on the same line.
        if first_end.line != second_start.line {
            return false;
        }

        // The column of the second's start must immediately follow the column of the first's end.
        first_end.column == second_start.column
    }
    ```

2.  **Modifying `parse_atom` (or equivalent):**

    The logic for parsing a rule call currently looks something like this:
    ```rust
    // Current (simplified)
    let rule_name: Ident = input.parse()?;
    let generics = ...; // parse generics
    let args = parse_args(input)?; // always consumes (...) if present
    ```

    We need to change it to:

    ```rust
    // Proposed
    let rule_name: Ident = input.parse()?;
    
    // Track the end of the previous token.
    let mut previous_end_span = rule_name.span();

    // Parse generics: rule<T, U>
    let generics = if input.peek(Token![<]) {
        // ... parsing generics ...
        let closing_gt: Token![>] = input.parse()?; // The '>' token
        previous_end_span = closing_gt.span(); // Update end span
        parsed_generics
    } else {
        Vec::new()
    };

    // Check for arguments
    let args = if input.peek(token::Paren) {
        // Peek the next token's span without consuming it
        let paren_span = input.cursor().span();
        
        if spans_are_contiguous(previous_end_span, paren_span) {
            // No gap: It's arguments for this rule.
            parse_args(input)? 
        } else {
            // Gap exists: It's a separate group.
            Vec::new()
        }
    } else {
        Vec::new()
    };

    Ok(Pattern::RuleCall {
        // ...
        args,
    })
    ```

3.  **Handling `parse_args`:**
    The `parse_args` function currently consumes a parenthesized group. It should remain largely the same, but it is now conditionally called.

4.  **Edge Cases:**
    - **Comments:** `syn`'s default behavior skips comments. If a comment is between `ident` and `(`, `syn` might treat them as adjacent tokens in the stream, but their spans will reflect the gap. `spans_are_contiguous` handles this correctly because the column numbers will differ significantly or the line numbers will differ.
    - **Macros:** If the grammar definition itself is generated by another macro, span information might be synthetic. However, `syn` usually preserves relative spans well enough for this to work in `proc_macro` contexts.

**Verification:**

We will add a specific test case in `tests/` that defines a grammar with:
1. `RuleA(x)` (call with arg)
2. `RuleB (y)` (call followed by group)
And asserts that the parsed model reflects this difference.
