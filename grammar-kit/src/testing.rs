//! Utilities for testing parsers generated by `syn-grammar`.
//!
//! This module provides a fluent API for testing parsing results,
//! asserting success/failure, and checking error messages.

use std::fmt::{Debug, Display};

// A wrapper around Result to write fluent tests.
pub struct TestResult<T, E> {
    inner: Result<T, E>,
    context: Option<String>,
}

impl<T: Debug, E: Display + Debug> TestResult<T, E> {
    pub fn new(result: Result<T, E>) -> Self {
        Self {
            inner: result,
            context: None,
        }
    }

    pub fn with_context(mut self, context: &str) -> Self {
        self.context = Some(context.to_string());
        self
    }

    fn format_context(&self) -> String {
        self.context
            .as_ref()
            .map(|c| format!("\nContext:  {}", c))
            .unwrap_or_default()
    }

    // 1. Asserts success and returns the value.
    pub fn assert_success(self) -> T {
        let ctx = self.format_context();
        match self.inner {
            Ok(val) => val,
            Err(e) => {
                panic!(
                    "\nðŸ”´ TEST FAILED (Expected Success, but got Error):{}\nMessage:  {}\nError Debug: {:?}\n", 
                    ctx, e, e
                );
            }
        }
    }

    // 2. Asserts success AND checks the value directly.
    // Returns a nice diff output if values do not match.
    pub fn assert_success_is<Exp>(self, expected: Exp) -> T
    where
        T: PartialEq<Exp>,
        Exp: Debug,
    {
        let ctx = self.format_context();
        let val = self.assert_success();
        if val != expected {
            panic!(
                "\nðŸ”´ TEST FAILED (Value Mismatch):{}\nExpected: {:?}\nGot:      {:?}\n",
                ctx, expected, val
            );
        }
        val
    }

    // 3. Asserts success AND checks the value using a closure.
    // Useful for complex assertions or when PartialEq is not implemented.
    pub fn assert_success_with<F>(self, f: F) -> T
    where
        F: FnOnce(&T),
    {
        let val = self.assert_success();
        f(&val);
        val
    }

    // 4. Asserts success AND checks the Debug representation matches.
    // Useful for syn types where PartialEq is often missing or complicated by Spans.
    pub fn assert_success_debug(self, expected_debug: &str) -> T {
        let ctx = self.format_context();
        let val = self.assert_success();
        let actual_debug = format!("{:?}", val);
        if actual_debug != expected_debug {
            panic!(
                "\nðŸ”´ TEST FAILED (Debug Mismatch):{}\nExpected: {:?}\nGot:      {:?}\n",
                ctx, expected_debug, actual_debug
            );
        }
        val
    }

    // 5. Asserts failure and returns the error.
    pub fn assert_failure(self) -> E {
        let ctx = self.format_context();
        match self.inner {
            Ok(val) => {
                panic!(
                    "\nðŸ”´ TEST FAILED (Expected Failure, but got Success):{}\nParsed Value: {:?}\n",
                    ctx, val
                );
            }
            Err(e) => e,
        }
    }

    // 6. Asserts failure AND checks if the message contains a specific text.
    pub fn assert_failure_contains(self, expected_msg_part: &str) {
        let ctx = self.format_context();
        let err = self.assert_failure();
        let actual_msg = err.to_string();
        if !actual_msg.contains(expected_msg_part) {
            panic!(
                "\nðŸ”´ TEST FAILED (Error Message Mismatch):{}\nExpected part: {:?}\nActual msg:    {:?}\nError Debug:   {:?}\n", 
                ctx, expected_msg_part, actual_msg, err
            );
        }
    }

    // 7. Asserts success AND checks if the string representation contains a specific substring.
    pub fn assert_success_contains(self, expected_part: &str) -> T
    where
        T: Display,
    {
        let ctx = self.format_context();
        let val = self.assert_success();
        let val_str = val.to_string();
        if !val_str.contains(expected_part) {
            panic!(
                "\nðŸ”´ TEST FAILED (Content Mismatch):{}\nExpected to contain: {:?}\nGot:                 {:?}\n",
                ctx, expected_part, val_str
            );
        }
        val
    }
}

pub trait Testable<T, E> {
    fn test(self) -> TestResult<T, E>;
}

#[cfg(feature = "syn")]
impl<T: Debug> Testable<T, syn::Error> for syn::Result<T> {
    fn test(self) -> TestResult<T, syn::Error> {
        TestResult::new(self)
    }
}
