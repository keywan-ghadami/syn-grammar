//! Utilities for testing parsers generated by `syn-grammar`.
//!
//! This module provides a fluent API for testing parsing results,
//! asserting success/failure, and checking error messages.

use std::fmt::Debug;

// A wrapper around syn::Result to write fluent tests.
pub struct TestResult<T> {
    inner: syn::Result<T>,
    context: Option<String>,
}

impl<T: Debug> TestResult<T> {
    pub fn new(result: syn::Result<T>) -> Self {
        Self { 
            inner: result,
            context: None,
        }
    }

    pub fn with_context(mut self, context: &str) -> Self {
        self.context = Some(context.to_string());
        self
    }

    fn format_context(&self) -> String {
        self.context.as_ref()
            .map(|c| format!("\nContext:  {}", c))
            .unwrap_or_default()
    }

    // 1. Asserts success and returns the value (as before).
    pub fn assert_success(self) -> T {
        let ctx = self.format_context();
        match self.inner {
            Ok(val) => val,
            Err(e) => {
                panic!(
                    "\nðŸ”´ TEST FAILED (Expected Success, but got Error):{}\nMessage:  {}\nLocation: {:?}\n", 
                    ctx, e, e.span()
                );
            }
        }
    }

    // 2. NEW: Asserts success AND checks the value directly.
    // Returns a nice diff output if values do not match.
    pub fn assert_success_is<E>(self, expected: E) -> T 
    where T: PartialEq<E>, E: Debug {
        let ctx = self.format_context();
        let val = self.assert_success();
        if val != expected {
            panic!(
                "\nðŸ”´ TEST FAILED (Value Mismatch):{}\nExpected: {:?}\nGot:      {:?}\n", 
                ctx, expected, val
            );
        }
        val
    }

    // 3. Asserts failure and returns the error.
    pub fn assert_failure(self) -> syn::Error {
        let ctx = self.format_context();
        match self.inner {
            Ok(val) => {
                panic!(
                    "\nðŸ”´ TEST FAILED (Expected Failure, but got Success):{}\nParsed Value: {:?}\n", 
                    ctx, val
                );
            }
            Err(e) => e,
        }
    }

    // 4. Asserts failure AND checks if the message contains a specific text.
    pub fn assert_failure_contains(self, expected_msg_part: &str) {
        let ctx = self.format_context();
        let err = self.assert_failure();
        let actual_msg = err.to_string();
        if !actual_msg.contains(expected_msg_part) {
            panic!(
                "\nðŸ”´ TEST FAILED (Error Message Mismatch):{}\nExpected part: {:?}\nActual msg:    {:?}\nLocation:      {:?}\n", 
                ctx, expected_msg_part, actual_msg, err.span()
            );
        }
    }
}

pub trait Testable<T> {
    fn test(self) -> TestResult<T>;
}

impl<T: Debug> Testable<T> for syn::Result<T> {
    fn test(self) -> TestResult<T> {
        TestResult::new(self)
    }
}
